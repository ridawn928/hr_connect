# HR Connect: Task 01-003-01 Implementation Guide

## Task Information
- **Task ID**: 01-003-01
- **Task Title**: Create a core/di/ directory for dependency injection configuration
- **Parent Task**: Project Setup and Architecture Foundation
- **Priority**: High

## Introduction

This guide provides step-by-step instructions for creating the core/di/ directory structure for dependency injection (DI) configuration in the HR Connect mobile workforce management solution. This task focuses on establishing the foundation for the dependency injection system, which is a critical component of the Modified Vertical Slice Architecture (MVSA) approach used in the project.

Dependency injection is a design pattern that promotes loose coupling between components, making the code more maintainable, testable, and flexible. In the HR Connect application, DI plays a crucial role in:

- Separating interface from implementation across all layers
- Supporting the Clean Architecture's dependency rule
- Facilitating test-driven development through easy mock injection
- Enabling feature isolation within the MVSA pattern
- Providing a consistent approach to component instantiation

This task sets up the directory structure and placeholder files that will be used in subsequent tasks to implement the actual DI system using get_it and injectable packages.

## Prerequisites

Before starting this task, ensure you have:

1. **Completed Previous Tasks**:
   - Tasks 01-001-01 through 01-001-05: Initial project setup and validation
   - Task 01-002-01: Created lib/core/ for shared utilities, constants, and base classes
   - Task 01-002-02: Created lib/features/ for feature-specific modules
   - Task 01-002-03: Added subfolders for presentation, domain, and data layers
   - Task 01-002-04: Added placeholder files to maintain structure in version control
   - Task 01-002-05: Written README files for each major directory

2. **Required Knowledge**:
   - Understanding of dependency injection principles
   - Familiarity with service locator pattern (get_it)
   - Basic knowledge of code generation in Flutter (injectable)
   - Understanding of the HR Connect architecture

3. **Installed Dependencies**:
   - get_it: ^7.6.0 (already added to pubspec.yaml in task 01-001-02)
   - injectable: ^2.1.2 (already added to pubspec.yaml in task 01-001-02)

## Dependency Injection in Clean Architecture

Before implementing the directory structure, it's important to understand how dependency injection supports the Clean Architecture principles used in HR Connect.

### The Dependency Rule

Clean Architecture follows a dependency rule where dependencies can only point inward:
- Inner layers (domain) know nothing about outer layers
- Outer layers (data, presentation) depend on inner layers

Dependency injection helps enforce this rule by:
- Defining interfaces (abstract classes) in the domain layer
- Implementing these interfaces in the data layer
- Injecting implementations through abstractions at runtime

### Benefits of get_it and injectable

HR Connect uses two primary packages for dependency injection:

1. **get_it**: A service locator that provides a global access point for retrieving registered services
   - Lightweight and efficient
   - No reflection (unlike some DI frameworks)
   - Supports different registration scopes (singleton, factory, etc.)

2. **injectable**: A code generation package that works with get_it
   - Reduces boilerplate code through annotations
   - Type-safe dependency resolution
   - Modular dependency registration
   - Supports different environments (dev, prod, test)

This combination provides a powerful yet flexible DI system that aligns well with the MVSA approach.

## Directory Structure and File Organization

The core/di/ directory will have the following structure:

```
lib/
  ├── core/
  │   ├── di/              # Dependency injection configuration
  │   │   ├── injection.dart     # Main entry point for DI
  │   │   ├── injection.config.dart  # Generated configuration (will be created by build_runner)
  │   │   ├── modules/     # Feature-specific DI modules
  │   │   │   └── .gitkeep      # Placeholder for future module files
  │   │   └── README.md    # Documentation for the DI directory
```

### Key Files and Their Purposes

1. **injection.dart**:
   - Main entry point for the DI configuration
   - Contains the getIt instance (service locator)
   - Configures injectable and initializes the DI container

2. **injection.config.dart**:
   - Generated by build_runner based on @injectable annotations
   - Contains all the registration code for dependencies
   - Should not be manually edited

3. **modules/ directory**:
   - Contains feature-specific dependency registration modules
   - Helps organize dependencies by feature or module
   - Supports the MVSA approach by keeping feature-specific registration separate

## Step-by-Step Implementation

Follow these steps to create the core/di/ directory structure and placeholder files:

### Step 1: Create the core/di/ Directory

First, ensure you're in the project directory and create the core/di/ directory:

```bash
# Navigate to the project directory
C:\Users\Darwin\Desktop\hr_connect

# Create the core/di directory
mkdir -p lib/core/di
```

### Step 2: Create the Main injection.dart File

Create the main injection.dart file that will serve as the entry point for the DI system:

```bash
# Create the injection.dart file
touch lib/core/di/injection.dart
```

Open the file in your editor and add the following content:

```dart
import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';

// This import will be generated later by build_runner
// ignore: unused_import, depend_on_referenced_packages
import 'injection.config.dart';

/// The global service locator instance.
final GetIt getIt = GetIt.instance;

/// Configures the dependency injection container.
///
/// This function should be called at app startup before any services
/// are accessed. It initializes the service locator with all registered
/// dependencies using the code generated by Injectable.
@InjectableInit(
  initializerName: r'$initGetIt', // default
  preferRelativeImports: true, // default
  asExtension: false, // default
)
void configureDependencies() => $initGetIt(getIt);
```

### Step 3: Create a Placeholder for injection.config.dart

The injection.config.dart file will be generated by build_runner in a later task, but we'll create a placeholder to maintain the directory structure:

```bash
# Create a directory to make sure the file can be imported
touch lib/core/di/injection.config.dart.placeholder
```

The placeholder is just to maintain the structure. The actual file will be generated in a later task.

### Step 4: Create the modules/ Directory

Create a directory for feature-specific DI modules:

```bash
# Create the modules directory
mkdir -p lib/core/di/modules

# Add a placeholder file
touch lib/core/di/modules/.gitkeep
```

This directory will later contain module files for each feature's dependency registration.

### Step 5: Create README.md for Documentation

Create a README.md file to document the purpose and usage of the DI directory:

```bash
# Create the README.md file
touch lib/core/di/README.md
```

Open the file in your editor and add the following content:

```markdown
# Dependency Injection Module

This directory contains the dependency injection configuration for the HR Connect application using get_it and injectable.

## Purpose

The dependency injection module:
- Provides a service locator pattern for resolving dependencies
- Generates boilerplate code for dependency registration
- Facilitates loose coupling between components
- Enables easier testing through dependency substitution

## Structure

- `injection.dart`: Main injection configuration entry point
- `injection.config.dart`: Generated configuration (don't edit manually)
- `modules/`: Feature-specific dependency registration modules

## Usage

### Registering a Dependency

To register a dependency, simply add the `@injectable` annotation to the class:

```dart
import 'package:injectable/injectable.dart';

@injectable
class MyService {
  // Implementation
}
```

For different registration types:

```dart
@singleton  // Single instance for the app lifetime
class DatabaseService {
  // Implementation
}

@lazySingleton  // Created only when first requested
class AuthService {
  // Implementation
}

@factoryMethod  // New instance each time
class ConfigService {
  // Implementation
}
```

### Using a Dependency

To use a registered dependency:

```dart
import 'package:hr_connect/core/di/injection.dart';

// In your code
final myService = getIt<MyService>();
```

### Feature Modules

For feature-specific dependencies, create a module file in the modules directory.

Example:

```dart
import 'package:injectable/injectable.dart';

@module
abstract class AuthenticationModule {
  @lazySingleton
  AuthService provideAuthService(AuthRepositoryImpl repository) => 
      AuthServiceImpl(repository);
}
```

## Notes

- Run `flutter pub run build_runner build` after adding or modifying injectable annotations
- Always register implementations against their interfaces for proper abstraction
- Use environment annotations for environment-specific dependencies
```

## File Content Templates

Here are detailed templates for the key files in the core/di/ directory:

### injection.dart

```dart
import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';

// This import will be generated later by build_runner
// ignore: unused_import, depend_on_referenced_packages
import 'injection.config.dart';

/// The global service locator instance.
final GetIt getIt = GetIt.instance;

/// Configures the dependency injection container.
///
/// This function should be called at app startup before any services
/// are accessed. It initializes the service locator with all registered
/// dependencies using the code generated by Injectable.
@InjectableInit(
  initializerName: r'$initGetIt', // default
  preferRelativeImports: true, // default
  asExtension: false, // default
)
void configureDependencies() => $initGetIt(getIt);

// The following manual registrations will be moved to the appropriate
// modules as the project evolves.

// Example of manual registration if needed:
// @InjectableInit() will handle most registrations automatically
// through code generation, but you can also register dependencies
// manually as shown below.
/*
void _configureManualDependencies() {
  // Register dependencies that need manual configuration
  getIt.registerSingleton<HttpClient>(
    HttpClient(baseUrl: 'https://api.example.com'),
  );
}
*/
```

### Example Feature Module (for future reference)

This is an example of how a feature module file might look in the future. You don't need to create this file now, but it serves as a reference for the structure:

```dart
// Example: lib/core/di/modules/network_module.dart
import 'package:injectable/injectable.dart';
import 'package:hr_connect/core/network/api_client.dart';
import 'package:hr_connect/core/network/connectivity_checker.dart';

@module
abstract class NetworkModule {
  // Provide instances that need specific initialization
  @singleton
  ApiClient provideApiClient() => ApiClient(
        baseUrl: 'https://api.example.com',
        timeout: const Duration(seconds: 30),
      );
  
  @lazySingleton
  ConnectivityChecker provideConnectivityChecker() => ConnectivityCheckerImpl();
}
```

## Verification Steps

After creating the core/di/ directory structure, verify that everything is set up correctly:

### 1. Check Directory Structure

Run the following command to verify the directory structure:

```bash
find lib/core/di -type f | sort
```

Expected output:
```
lib/core/di/injection.config.dart.placeholder
lib/core/di/injection.dart
lib/core/di/modules/.gitkeep
lib/core/di/README.md
```

### 2. Verify File Content

Check that the injection.dart file has the correct content:

```bash
cat lib/core/di/injection.dart
```

Ensure that it matches the template provided above.

### 3. Commit Changes to Version Control

Once you've verified the structure, commit the changes to Git:

```bash
git add lib/core/di
git commit -m "Create core/di directory for dependency injection configuration"
```

## Common Issues and Solutions

### Issue: Import Errors with injection.config.dart

**Problem**: IDE shows errors for the import of injection.config.dart since the file doesn't exist yet.

**Solution**:
- Add an ignore comment to suppress the error: `// ignore: unused_import, depend_on_referenced_packages`
- Create an empty injection.config.dart file as a temporary placeholder
- The actual file will be generated in a later task when build_runner is executed

### Issue: Confusion About Manual vs. Generated Registration

**Problem**: Uncertainty about whether to manually register dependencies or rely on the code generation.

**Solution**:
- The injectable package will handle most registrations through code generation based on annotations
- Manual registration should be used only for special cases where you need custom initialization logic
- Most dependencies will be registered using the `@injectable`, `@singleton`, or `@lazySingleton` annotations

### Issue: Module Organization Strategy

**Problem**: Confusion about how to organize modules for different features.

**Solution**:
- For now, just create the modules/ directory
- In future tasks, modules can be organized by feature, layer, or technical concern
- The most common approach is to have one module per feature or technical concern (network, storage, etc.)

## Next Steps

After successfully creating the core/di/ directory structure, proceed to:

1. **Task 01-003-02**: Implement the service locator using get_it
2. **Task 01-003-03**: Integrate injectable and set up the initial injection configuration file with @InjectableInit

These subsequent tasks will:
- Complete the configuration of the dependency injection system
- Set up code generation for automatic dependency registration
- Connect the DI system to the application's startup process

As the project progresses, you'll add feature-specific modules in the modules/ directory to organize dependency registration in a way that aligns with the MVSA approach.

## References

- [HR Connect PRD Section 8.1: Framework and Architecture](docs/requirements.md)
- [HR Connect Flutter Development Guidelines](docs/guidelines.md)
- [get_it Package Documentation](https://pub.dev/packages/get_it)
- [injectable Package Documentation](https://pub.dev/packages/injectable)
- [Clean Architecture in Flutter](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

---

*Note for Cursor AI: When implementing this task, ensure the directory structure follows exactly the pattern specified above. The injection.dart file should be created with the content provided in the template, but the actual implementation of dependency injection will be done in subsequent tasks. This task focuses solely on setting up the directory structure and placeholder files.*
